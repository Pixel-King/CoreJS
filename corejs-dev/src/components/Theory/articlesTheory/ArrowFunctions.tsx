import * as React from 'react';

const ArrowFunctions: React.FC =() => {
    return (
    <>

    <h1>Стрелочные функции, основы</h1>
    <p>Существует ещё один очень простой и лаконичный синтаксис для создания функций, который часто лучше, чем Function Expression.</p>
    <p>Он называется &quot;функции-стрелки&quot; или &quot;стрелочные функции&quot; (arrow functions), т.к. выглядит следующим образом:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code>
            let func = (arg1, arg2, ...argN) =&gt; expression;
        </code>
    </pre>
    <p>Это создаёт функцию <code>func</code>, которая принимает аргументы <code>arg1..argN</code>, затем вычисляет <code>expression</code> в правой части с их использованием и возвращает результат.</p>
    <p>Другими словами, это сокращённая версия:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code>
            {`let func = function(arg1, arg2, ...argN) {`} <br />
            {`    return expression;`} <br />
            {`};`}
        </code>
    </pre>
    <p>Давайте рассмотрим конкретный пример:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code>
            {`let sum = (a, b) => a + b;`} <br />
            {``} <br />
            {`/* Эта стрелочная функция представляет собой более короткую форму:`} <br />
            {``} <br />
            {`let sum = function(a, b) {`} <br />
            {`    return a + b;`} <br />
            {`};`} <br />
            {`*/`} <br />
            {``} <br />
            {`alert( sum(1, 2) ); // 3`}
        </code>
    </pre>
    <p>Как вы можете видеть, <code>(a, b) =&gt; a + b</code> задаёт функцию, которая принимает два аргумента с именами <code>a</code> и <code>b</code>. И при выполнении она вычисляет выражение <code>a + b</code> и возвращает результат.</p>
    <ul>
        <li>
            <p>Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:</p>
            <pre className="text-bg-dark px-3 py-3">
                <code>
                    *!* <br />
                    let double = n =&gt; n * 2; <br />
                    {`// примерно тоже что и: let double = function(n) { return n * 2 }`} <br />
                    */!* <br />
                    {``} <br />
                    alert( double(3) ); // 6
                </code>
            </pre>
        </li>
        <li>
            <p>Если аргументов нет, круглые скобки будут пустыми, но они должны присутствовать:</p>
            <pre className="text-bg-dark px-3 py-3">
                <code>
                    let sayHi = () =&gt; alert(&quot;Hello!&quot;); <br />
                    {``} <br />
                    sayHi();
                </code>
            </pre>
        </li>
    </ul>
    <p>Стрелочные функции можно использовать так же, как и Function Expression.</p>
    <p>Например, для динамического создания функции:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code>
            let age = prompt(&quot;Сколько Вам лет?&quot;, 18); <br />
            {``} <br />
            let welcome = (age &lt; 18) ? <br />
            () =&gt; alert(&#39;Привет!&#39;) : <br />
            () =&gt; alert(&quot;Здравствуйте!&quot;); <br />
            {``} <br />
            welcome();
        </code>
    </pre>
    <p>Поначалу стрелочные функции могут показаться необычными и даже трудночитаемыми, но это быстро пройдёт по мере того, как глаза привыкнут к этим конструкциям.</p>
    <p>Они очень удобны для простых однострочных действий, когда лень писать много слов.</p>
    <h2>Многострочные стрелочные функции</h2>
    <p>Стрелочные функции, которые мы видели до этого, были очень простыми. Они брали аргументы слева от <code>=&gt;</code> и вычисляли и возвращали выражение справа.</p>
    <p>Иногда нам нужна более сложная функция, с несколькими выражениями и инструкциями. Это также возможно, нужно лишь заключить их в фигурные скобки. При этом важное отличие - в том, что в таких скобках для возврата значения нужно использовать <code>return</code> (как в обычных функциях).</p>
    <p>Вроде этого:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code>
            {`let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции`} <br />
            {`    let result = a + b;`} <br />
            {`    *!*`} <br />
            {`    return result; // если мы используем фигурные скобки, то нам нужно явно указать 'return'`} <br />
            {`    */!*`} <br />
            {`};`} <br />
            {``} <br />
            alert( sum(1, 2) ); // 3
        </code>
    </pre>

    <h2 id="итого">Итого</h2>
    <p>Стрелочные функции очень удобны для простых действий, особенно для однострочных.</p>
    <p>Они бывают двух типов:</p>
    <ol>
        <li>Без фигурных скобок: <code>(...args) =&gt; expression</code> -- правая сторона выражения: функция вычисляет его и возвращает результат. Скобки можно не ставить, если аргумент только один: <code>n =&gt; n * 2</code>.</li>
        <li>С фигурными скобками: <code>(...args) =&gt; {`{ body }`}</code> -- скобки позволяют нам писать несколько инструкций внутри функции, но при этом необходимо явно вызывать <code>return</code>, чтобы вернуть значение.</li>
    </ol>

    </>
    );
}

export default ArrowFunctions;