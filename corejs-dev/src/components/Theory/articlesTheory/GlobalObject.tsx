import * as React from 'react';

const GlobalObject: React.FC =() => {
    return (
    <>
    <h1>Глобальный объект</h1>
    <p>Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. По умолчанию это те, что встроены в язык или среду исполнения.</p>
    <p>В браузере он называется <em>window</em>, в Node.js — <em>global</em>, в другой среде исполнения может называться иначе.</p>
    <p>Недавно <code className="fs-6">globalThis</code> был добавлен в язык как стандартизированное имя для глобального объекта, которое должно поддерживаться в любом окружении. В некоторых браузерах, например в старой версии Edge который не был на Chromium, <code className="fs-6">globalThis</code> ещё не поддерживается, но легко реализуется с помощью полифила.</p>
    <p>Далее мы будем использовать <code className="fs-6">window</code>, полагая, что наша среда – браузер. Если скрипт может выполняться и в другом окружении, лучше будет <code className="fs-6">globalThis</code>.</p>
    <p>Ко всем свойствам глобального объекта можно обращаться напрямую:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`alert("Привет");
// это то же самое, что и
window.alert("Привет");`}
        </code>
    </pre>
    <p>В браузере глобальные функции и переменные, объявленные с помощью <code className="fs-6">var</code> (не <code className="fs-6">let/const</code>!), становятся свойствами глобального объекта:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
            {`var gVar = 5;

alert(window.gVar); // 5 (становится свойством глобального объекта)`}
        </code>
    </pre>
    <p>Пожалуйста, не полагайтесь на это. Такое поведение поддерживается для совместимости. В современных проектах, использующих JavaScript-модули, такого не происходит.</p>
    <p>Если бы мы объявили переменную при помощи <code className="fs-6">let</code>, то такого бы не произошло:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
            {`let gLet = 5;

alert(window.gLet); // undefined (не становится свойством глобального объекта)`}
        </code>
    </pre>
    <p>Если свойство настолько важное, что вы хотите сделать его доступным для всей программы, запишите его в глобальный объект напрямую:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
            {`// сделать информацию о текущем пользователе глобальной, для предоставления доступа всем скриптам
window.currentUser = {
  name: "John"
};

// где угодно в коде
alert(currentUser.name); // John

// или, если у нас есть локальная переменная с именем "currentUser",
// получим её из window явно (безопасно!)
alert(window.currentUser.name); // John`}
        </code>
    </pre>
    <p>При этом обычно не рекомендуется использовать глобальные переменные. Следует применять их как можно реже. Дизайн кода, при котором функция получает входные параметры и выдаёт определённый результат, чище, надёжнее и удобнее для тестирования, чем когда используются внешние, а тем более глобальные переменные.</p>
    <h2>Использование для полифилов</h2>
    <p>Глобальный объект можно использовать, чтобы проверить поддержку современных возможностей языка.</p>
    <p>Например, проверить наличие встроенного объекта <em>Promise</em> (такая поддержка отсутствует в очень старых браузерах):</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`if (!window.Promise) {
    alert("Ваш браузер очень старый!");
}`}
        </code>
    </pre>
    <p>Если нет (скажем, используется старый браузер), мы можем создать полифил: добавить функции, которые не поддерживаются окружением, но существуют в современном стандарте.</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
            {`if (!window.Promise) {
    window.Promise = ... // собственная реализация современной возможности языка
}`}
        </code>
    </pre>
    <h2>Итого</h2>
    <ul>
        <li>
            <p>Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.</p>
            <p>Это включает в себя как встроенные объекты, например, <code className="fs-6">Array</code>, так и характерные для окружения свойства, например, <code className="fs-6">window.innerHeight</code> – высота окна браузера.</p>
        </li>
        <li>
            <p>Глобальный объект имеет универсальное имя – <code className="fs-6">globalThis</code>.</p>
            <p>…Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как <code className="fs-6">window</code> (браузер) и <code className="fs-6">global</code> (Node.js). Так как <code className="fs-6">globalThis</code> появился недавно, он не поддерживается в IE и Edge (не-Chromium версия), но можно использовать полифил.</p>
        </li>
        <li>
            <p>Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их количество к минимуму.</p>
        </li>
        <li>
            <p>В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью <code className="fs-6">var</code>, становятся свойствами глобального объекта.</p>
        </li>
        <li>
            <p>Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую, как <code className="fs-6">window.x</code>.</p>
        </li>
    </ul>

    </>
    );
}

export default GlobalObject;