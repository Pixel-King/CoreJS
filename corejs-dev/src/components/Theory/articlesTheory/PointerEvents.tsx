import * as React from 'react';

const PointerEvents: React.FC =() => {
    return (
    <>
    <h1>События указателя</h1>
    <p>События указателя (Pointer events) – это современный способ обработки ввода с помощью различных указывающих устройств, таких как мышь, перо/стилус, сенсорный экран и так далее.</p>
    <h2>Краткая история</h2>
    <p>Сделаем небольшой обзор, чтобы вы поняли общую картину и место событий указателя среди других типов событий.</p>
    <ul>
        <li>
            <p>Давным-давно, в прошлом, существовали только события мыши</p>
            <p>Затем получили широкое распространение сенсорные устройства, в частности телефоны и планшеты. Чтобы скрипты корректно работали, они генерировали (и до сих пор генерируют) события мыши. Например, касание сенсорного экрана генерирует событие <strong>mousedown</strong>. Таким образом, сенсорные устройства позволяли работать с существующими веб-страницами.</p>
            <p>Но сенсорные устройства во многих аспектах мощнее, чем мышь. Например, они позволяют касаться экрана сразу в нескольких местах («мульти-тач»). Однако, события мыши не имеют необходимых свойств для обработки таких прикосновений.</p>
        </li>
        <li>
            <p>Поэтому появились события касания (Touch events), такие как <strong>touchstart</strong>, <strong>touchend</strong>, <strong>touchmove</strong>, которые имеют специфичные для касаний свойства (мы не будем здесь рассматривать их подробно, потому что события указателя ещё лучше).</p>
            <p>Но и этих событий оказалось недостаточно, так как существует много других устройств, таких как перо, у которых есть свои особенности. Кроме того, универсальный код, который отслеживал бы и события касаний и события мыши, неудобно писать.</p>
        </li>
        <li>
            <p>Для решения этих задач был внедрён стандарт Pointer Events («События Указателя»). Он предоставляет единый набор событий для всех типов указывающих устройств.</p>
        </li>
    </ul>
    <p>К настоящему времени спецификация <a href="https://www.w3.org/TR/pointerevents2/">Pointer Events Level 2</a> поддерживается всеми основными браузерами, а <a href="https://w3c.github.io/pointerevents/">Pointer Events Level 3</a> находится в разработке и почти полностью совместима с Pointer Events Level 2.</p>
    <p>Если вы не разрабатываете под старые браузеры, такие как Internet Explorer 10, Safari 12, или более ранние версии, больше нет необходимости использовать события мыши или касаний – можно переходить сразу на события указателя.</p>
    <p>При этом ваш код будет корректно работать и с сенсорными устройствами и с мышью. Впрочем, у событий указателя есть важные особенности, которые нужно знать, чтобы их правильно использовать, без лишних сюрпризов. Мы отметим их в этой статье.</p>
    <h2>Типы событий указателя</h2>
    <p>Схема именований событий указателя похожа на события мыши:</p>
    <table className="table table-bordered text-center">
        <thead>
            <tr>
                <th scope="col"><p><strong>Событие указателя</strong></p></th>
                <th scope="col"><p><strong>Аналогичное событие мыши</strong></p></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><p><strong>pointerdown</strong></p></td>
                <td><p><strong>mousedown</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>pointerup</strong></p></td>
                <td><p><strong>mouseup</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>pointermove</strong></p></td>
                <td><p><strong>mousemove</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>pointerover</strong></p></td>
                <td><p><strong>mouseover</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>pointerout</strong></p></td>
                <td><p><strong>mouseout</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>pointerenter</strong></p></td>
                <td><p><strong>mouseenter</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>pointerleave</strong></p></td>
                <td><p><strong>mouseleave</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>pointercancel</strong></p></td>
                <td><p><strong>-</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>gotpointercapture</strong></p></td>
                <td><p><strong>-</strong></p></td>
            </tr>
            <tr>
                <td><p><strong>lostpointercapture</strong></p></td>
                <td><p><strong>-</strong></p></td>
            </tr>
        </tbody>
    </table>
    <p>Как мы видим, для каждого <strong>{`mouse<события>`}</strong> есть соответствующее <strong>{`pointer<событие>`}</strong>, которое играет аналогичную роль. Также есть 3 дополнительных события указателя, у которых нет соответствующего аналога <strong>mouse...</strong>, скоро мы их разберём.</p>
    <div className="fst-italic border-3 border-start border-warning px-3">
        <p><strong>Замена {`mouse<событий>`} на {`pointer<события>`} в коде</strong></p>
        <p>Мы можем заменить события <strong>mouse...</strong> на аналогичные <strong>pointer...</strong> в коде и быть уверенными, что с мышью по-прежнему всё будет работать нормально.</p>
        <p>При этом поддержка сенсорных устройств «волшебным» образом улучшится. Хотя, возможно, кое-где понадобится добавить <code className="fs-6">touch-action: none</code> в CSS. Подробнее мы разберём это ниже, в секции про <strong>pointercancel</strong>.</p>
    </div>
    <h2>Свойства событий указателя</h2>
    <p>События указателя содержат те же свойства, что и события мыши, например <code className="fs-6">clientX/Y</code>, <code className="fs-6">target</code> и т.п., и несколько дополнительных:</p>
    <ul>
        <li>
            <p><code className="fs-6">pointerId</code> – уникальный идентификатор указателя, вызвавшего событие.</p>
            <p>Идентификатор генерируется браузером. Это свойство позволяет обрабатывать несколько указателей, например сенсорный экран со стилусом и мульти-тач (увидим примеры ниже).</p>
        </li>
        <li>
            <p><code className="fs-6">pointerType</code> – тип указывающего устройства. Должен быть строкой с одним из значений: «mouse», «pen» или «touch».</p>
            <p>Мы можем использовать это свойство, чтобы определять разное поведение для разных типов указателей.</p>
        </li>
        <li>
            <p><code className="fs-6">isPrimary</code> – равно <code className="fs-6">true</code> для основного указателя (первый палец в мульти-тач).</p>
        </li>
    </ul>
    <p>Некоторые устройства измеряют область контакта и степень надавливания, например пальца на сенсорном экране, для этого есть дополнительные свойства:</p>
    <ul>
        <li>
            <p><code className="fs-6">width</code> – ширина области соприкосновения указателя (например, пальца) с устройством. Если не поддерживается, например мышью, то всегда равно <code className="fs-6">1</code>.</p>
        </li>
        <li>
            <p><code className="fs-6">height</code> – высота области соприкосновения указателя с устройством. Если не поддерживается, например мышью, то всегда равно <code className="fs-6">1</code>.</p>
        </li>
        <li>
            <p><code className="fs-6">pressure</code> – степень давления указателя в диапазоне от <code className="fs-6">0</code> до <code className="fs-6">1</code>. Для устройств, которые не поддерживают давление, принимает значение <code className="fs-6">0.5</code> (нажато) либо <code className="fs-6">0</code>.</p>
        </li>
        <li>
            <p><code className="fs-6">tangentialPressure</code> – нормализованное тангенциальное давление.</p>
        </li>
        <li>
            <p><code className="fs-6">tiltX</code>, <code className="fs-6">tiltY</code>, <code className="fs-6">twist</code> – специфичные для пера свойства, описывающие положение пера относительно сенсорной поверхности.</p>
        </li>
    </ul>
    <p>Эти свойства большинством устройств не поддерживаются, поэтому редко используются. При необходимости, подробности о них можно найти в <a href="https://w3c.github.io/pointerevents/#pointerevent-interface">спецификации</a>.</p>
    <h2>Мульти-тач</h2>
    <p>Одной из функций, которую абсолютно не поддерживают события мыши, является мульти-тач: возможность касаться сразу нескольких мест на телефоне или планшете или выполнять специальные жесты.</p>
    <p>События указателя позволяют обрабатывать мульти-тач с помощью свойств <code className="fs-6">pointerId</code> и <code className="fs-6">isPrimary</code>.</p>
    <p>Вот что происходит, когда пользователь касается сенсорного экрана в одном месте, а затем в другом:</p>
    <ol>
        <li>
            <p>При касании первым пальцем:</p>
            <ul>
                <li>
                    <p>происходит событие <code className="fs-6">pointerdown</code> со свойством <code className="fs-6">isPrimary=true</code> и некоторым <code className="fs-6">pointerId</code>.</p>
                </li>
            </ul>
        </li>
        <li>
            <p>При касании вторым и последующими пальцами (при остающемся первом):</p>
            <ul>
                <li>
                    <p>происходит событие <code className="fs-6">pointerdown</code> со свойством <code className="fs-6">isPrimary=false</code> и уникальным <code className="fs-6">pointerId</code> для каждого касания.</p>
                </li>
            </ul>
        </li>
    </ol>
    <p>Обратите внимание: <code className="fs-6">pointerId</code> присваивается не на всё устройство, а для каждого касающегося пальца. Если коснуться экрана 5 пальцами одновременно, получим 5 событий <strong>pointerdown</strong>, каждое со своими координатами и индивидуальным <code className="fs-6">pointerId</code>.</p>
    <p>События, связанные с первым пальцем, всегда содержат свойство <code className="fs-6">isPrimary=true</code>.</p>
    <p>Мы можем отслеживать несколько касающихся экрана пальцев, используя их <code className="fs-6">pointerId</code>. Когда пользователь перемещает, а затем убирает палец, получаем события <strong>pointermove</strong> и <strong>pointerup</strong> с тем же <code className="fs-6">pointerId</code>, что и при событии <strong>pointerdown</strong>.</p>
    <p>Вот <a href="https://plnkr.co/edit/YdSmltntYmOP2IBe?p=preview&preview">небольшое демо</a>, выводящее события <strong>pointerdown</strong> и <strong>pointerup</strong>.</p>
    <p>Обратите внимание: чтобы увидеть разницу в <code className="fs-6">pointerId/isPrimary</code>, вам нужно использовать устройство с сенсорным экраном, такое как телефон или планшет. Для устройств без поддержки мульти-тач, таких как мышь, всегда будет один и тот же <code className="fs-6">pointerId</code> со свойством <code className="fs-6">isPrimary=true</code>, для всех событий указателя.</p>
    <h2>Событие: pointercancel</h2>
    <p>Событие <strong>pointercancel</strong> происходит, когда текущее действие с указателем по какой-то причине прерывается, и события указателя больше не генерируются.</p>
    <p>К таким причинам можно отнести:</p>
    <ul>
        <li>
            <p>Указывающее устройство было физически выключено.</p>
        </li>
        <li>
            <p>Изменилась ориентация устройства (перевернули планшет).</p>
        </li>
        <li>
            <p>Браузер решил сам обработать действие, считая его жестом мыши, масштабированием и т.п.</p>
        </li>
    </ul>
    <p>Мы продемонстрируем <strong>pointercancel</strong> на практическом примере, чтобы увидеть, как это влияет на нас.</p>
    <p>Допустим, мы реализуем перетаскивание («drag-and-drop») для нашего мяча, как в начале статьи Drag'n'Drop с событиями мыши.</p>
    <p>Вот последовательность действий пользователя и соответствующие события:</p>
    <ol>
        <li>
            <p>Пользователь нажимает на изображение, чтобы начать перетаскивание</p>
            <ul>
                <li>
                    <p>происходит событие <strong>pointerdown</strong></p>
                </li>
            </ul>
        </li>
        <li>
            <p>Затем он перемещает указатель, двигая изображение</p>
            <ul>
                <li>
                    <p>происходит событие pointermove (возможно, несколько раз)</p>
                </li>
            </ul>
        </li>
        <li>
            <p>И тут происходит сюрприз! Браузер имеет встроенную поддержку «Drag'n'Drop» для изображений, которая запускает и перехватывает процесс перетаскивания, генерируя при этом событие <strong>pointercancel</strong>.</p>
            <ul>
                <li>
                    <p>Теперь браузер сам обрабатывает перетаскивание изображения. У пользователя есть возможность перетащить изображение мяча даже за пределы браузера, в свою почтовую программу или файловый менеджер.</p>
                </li>
                <li>
                    <p>Событий <strong>pointermove</strong> для нас больше не генерируется.</p>
                </li>
            </ul>
        </li>
    </ol>
    <p>Таким образом, браузер «перехватывает» действие: в начале переноса drag-and-drop запускается событие <strong>pointercancel</strong>, и после этого события <strong>pointermove</strong> больше не генерируются.</p>
    <p>Вот <a href="https://plnkr.co/edit/z4QYwkDQA3aJW29v?p=preview&preview">демо</a> drag'n'drop с записью событий указателя (только <strong>up/down</strong>, <strong>move</strong> и <strong>cancel</strong>) в <code className="fs-6">textarea</code>.</p>
    <p>Мы бы хотели реализовать перетаскивание самостоятельно, поэтому давайте скажем браузеру не перехватывать его.</p>
    <p><strong>Предотвращайте действие браузера по умолчанию, чтобы избежать <em>pointercancel</em>.</strong></p>
    <p>Нужно сделать две вещи:</p>
    <ol>
        <li>
            <p>Предотвратить запуск встроенного drag'n'drop</p>
            <ul>
                <li>
                    <p>Мы можем сделать это, задав <code className="fs-6">{`ball.ondragstart = () => false`}</code>, как описано в статье Drag'n'Drop с событиями мыши.</p>
                </li>
                <li>
                    <p>Это работает для событий мыши.</p>
                </li>
            </ul>
        </li>
        <li>
            <p>Для устройств с сенсорным экраном существуют другие действия браузера, связанные с касаниями, кроме drag'n'drop. Чтобы с ними не возникало проблем:</p>
            <ul>
                <li>
                    <p>Мы можем предотвратить их, добавив в CSS свойство <code className="fs-6">{`#ball { touch-action: none }`}</code>.</p>
                </li>
                <li>
                    <p>Затем наш код начнёт корректно работать на устройствах с сенсорным экраном</p>
                </li>
            </ul>
        </li>
    </ol>
    <p>После того, как мы это сделаем, события будут работать как и ожидается, браузер не будет перехватывать процесс и не будет вызывать событие pointercancel.</p>
    <p>В данном <a href="https://plnkr.co/edit/Lklq5wpRB8g4LF17?p=preview&preview">демо</a> произведены нужные действия.</p>
    <p>Как вы можете видеть, событие <strong>pointercancel</strong> больше не срабатывает.</p>
    <p>Теперь мы можем добавить код для перемещения мяча и наш drag'n'drop будет работать и для мыши и для устройств с сенсорным экраном.</p>
    <h2>Захват указателя</h2>
    <p>Захват указателя – особая возможность событий указателя.</p>
    <p>Общая идея очень проста, но поначалу может показаться странной, так как для других событий ничего подобного просто нет.</p>
    <p>Основной метод:</p>
    <ul>
        <li>
            <p><code className="fs-6">elem.setPointerCapture(pointerId)</code> – привязывает события с данным <code className="fs-6">pointerId</code> к <strong>elem</strong>. После такого вызова все события указателя с таким <code className="fs-6">pointerId</code> будут иметь <strong>elem</strong> в качестве целевого элемента (как будто произошли над <strong>elem</strong>), вне зависимости от того, где в документе они произошли.</p>
        </li>
    </ul>
    <p>Другими словами, <code className="fs-6">elem.setPointerCapture(pointerId)</code> меняет <code className="fs-6">target</code> всех дальнейших событий с данным <code className="fs-6">pointerId</code> на <strong>elem</strong>.</p>
    <p>Эта привязка отменяется:</p>
    <ul>
        <li>
            <p>автоматически, при возникновении события <strong>pointerup</strong> или <strong>pointercancel</strong></p>
        </li>
        <li>
            <p>автоматически, если <strong>elem</strong> удаляется из документа</p>
        </li>
        <li>
            <p>при вызове <code className="fs-6">elem.releasePointerCapture(pointerId)</code>.</p>
        </li>
    </ul>
    <p><strong>Захват указателя используется для упрощения операций с переносом (drag'n'drop) элементов.</strong></p>
    <p>В качестве примера давайте вспомним реализацию слайдера из статьи Drag'n'Drop с событиями мыши.</p>
    <p>Мы делаем элемент для слайдера – полоску с «ползунком» (thumb) внутри.</p>
    <p>Затем он работает так:</p>
    <ol>
        <li>
            <p>Пользователь сначала нажимает на ползунок – срабатывает <strong>pointerdown</strong>.</p>
        </li>
        <li>
            <p>Затем двигает указателем его – срабатывает <strong>pointermove</strong>, и мы передвигаем ползунок вместе с ним.</p>
            <ul>
                <li>
                    <p>…Причём, по мере движения, указатель может покидать ползунок – перемещаться выше или ниже. При этом ползунок должен передвигаться строго по горизонтали, на одной линии с указателем.</p>
                </li>
            </ul>
        </li>
    </ol>
    <p>Так что для полного отслеживания перемещения указателя, включая ниже и выше ползунка, нам пришлось поставить обработчик <strong>pointermove</strong> на весь документ <strong>document</strong>.</p>
    <p>Такое решение выглядит слегка «грязным». Одна из проблем – это то, что движения указателя по документу могут вызвать сторонние эффекты, заставить сработать другие обработчики, не имеющие отношения к слайдеру.</p>
    <p>Захват указателя позволяет привязать <strong>pointermove</strong> к <strong>thumb</strong> и избежать любых подобных проблем:</p>
    <ul>
        <li>
            <p>Мы можем вызывать <code className="fs-6">thumb.setPointerCapture(event.pointerId)</code> в обработчике <strong>pointerdown</strong>,</p>
        </li>
        <li>
            <p>Тогда дальнейшие события указателя до <strong>pointerup/cancel</strong> будут привязаны к <strong>thumb</strong>.</p>
        </li>
        <li>
            <p>Затем, когда произойдёт <strong>pointerup</strong> (передвижение завершено), привязка будет автоматически удалена, нам об этом не нужно беспокоиться.</p>
        </li>
    </ul>
    <p>Так что, даже если пользователь будет двигать указателем по всему документу, обработчики событий будут вызваны на <strong>thumb</strong>. Причём все свойства объекта события, такие как <code className="fs-6">clientX/clientY</code>, будут корректны – захват указателя влияет только на <code className="fs-6">target/currentTarget</code>.</p>
    <p>Вот основной код:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
            {`thumb.onpointerdown = function(event) {
  // все события указателя перенаправить на thumb (пока не произойдёт 'pointerup')
  thumb.setPointerCapture(event.pointerId);
};

thumb.onpointermove = function(event) {
  // перемещение ползунка: все события перенаправлены на этот обработчик
  let newLeft = event.clientX - slider.getBoundingClientRect().left;
  thumb.style.left = newLeft + 'px';
};

// примечание: нет необходимости вызывать thumb.releasePointerCapture,
// при срабатывании события 'pointerup' это происходит автоматически`}
        </code>
    </pre>
    <p>Полное <a href="https://plnkr.co/edit/2r997UrTN6xzWSs4?p=preview&preview">демо</a>.</p>
    <p>Таким образом, мы имеем два бонуса:</p>
    <ol>
        <li>
            <p>Код становится чище, поскольку нам больше не нужно добавлять/удалять обработчики для всего документа. Удаление привязки происходит автоматически.</p>
        </li>
        <li>
            <p>Если в документе есть какие-то другие обработчики <strong>pointermove</strong>, то они не будут нечаянно вызваны, пока пользователь находится в процессе перетаскивания слайдера.</p>
        </li>
    </ol>
    <h2>События при захвате указателя</h2>
    <p>Существует два связанных с захватом события:</p>
    <ul>
        <li>
            <p>gotpointercapture срабатывает, когда элемент использует <code className="fs-6">setPointerCapture</code> для включения захвата.</p>
        </li>
        <li>
            <p><strong>lostpointercapture</strong> срабатывает при освобождении от захвата: явно с помощью <strong>releasePointerCapture</strong> или автоматически, когда происходит событие <strong>pointerup/pointercancel</strong>.</p>
        </li>
    </ul>
    <h2>Итого</h2>
    <p>События указателя позволяют одновременно обрабатывать действия с помощью мыши, касания и пера, в едином фрагменте кода.</p>
    <p>События указателя расширяют события мыши. Мы можем заменить <strong>mouse</strong> на <strong>v</strong> в названиях событий и код продолжит работать для мыши, при этом получив лучшую поддержку других типов устройств.</p>
    <p>При обработке переносов и сложных касаний, которые браузер может попытаться обработать сам, не забывайте отменять действие браузера и ставить <code className="fs-6">touch-action: none</code> в CSS для элементов, с которыми мы взаимодействуем.</p>
    <p>Дополнительные возможности событий указателя:</p>
    <ul>
        <li>
            <p>Поддержка мультитач с помощью <code className="fs-6">pointerId</code> и <code className="fs-6">isPrimary</code>.</p>
        </li>
        <li>
            <p>Особые свойства для определённых устройств, такие как <code className="fs-6">pressure</code>, <code className="fs-6">width/height</code> и другие.</p>
        </li>
        <li>
            <p>Захват указателя: мы можем перенаправить все события указателя на определённый элемент до наступления события <strong>pointerup/pointercancel</strong>.</p>
        </li>
    </ul>
    <p>На данный момент события указателя поддерживаются в основных браузерах, поэтому мы можем безопасно переходить на них, особенно если нет необходимости в поддержке IE10 и Safari 12. И даже для этих браузеров есть полифилы, которые добавляют эту поддержку.</p>

    </>
    );
}

export default PointerEvents;