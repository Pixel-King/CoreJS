import * as React from 'react';

const SymbolType: React.FC =() => {
    return (
    <>
    <h1>Тип данных Symbol</h1>
    <p>По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.</p>
    <h2>Символы</h2>
    <p>«Символ» представляет собой уникальный идентификатор.</p>
    <p>Создаются новые символы с помощью функции <code className="fs-6">Symbol()</code>:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
            {`// Создаём новый символ - id
let id = Symbol();`}
        </code>
    </pre>
    <p>При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");`}
        </code>
    </pre>
    <p>Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.</p>
    <p>Например, вот два символа с одинаковым описанием – но они не равны:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false`}
        </code>
    </pre>
    <p>Если вы знаете Ruby или какой-то другой язык программирования, в котором есть своего рода «символы» – пожалуйста, будьте внимательны. Символы в JavaScript имеют свои особенности, и не стоит думать о них, как о символах в Ruby или в других языках.</p>
    <div className="fst-italic border-3 border-start border-warning px-3">
        <p><strong>Символы не преобразуются автоматически в строки</strong></p>
        <p>Большинство типов данных в JavaScript могут быть неявно преобразованы в строку. Например, функция <code className="fs-6">alert</code> принимает практически любое значение, автоматически преобразовывает его в строку, а затем выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически.</p>
        <p>К примеру, <code className="fs-6">alert</code> ниже выдаст ошибку:</p>
        <pre className="text-bg-dark px-3 py-3">
            <code className="fs-6">
            {`let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string`}
            </code>
        </pre>
        <p>Это – языковая «защита» от путаницы, ведь строки и символы – принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.</p>
        <p>Если же мы действительно хотим вывести символ с помощью <code className="fs-6">alert</code>, то необходимо явно преобразовать его с помощью метода <code className="fs-6">.toString()</code>, вот так:</p>
        <pre className="text-bg-dark px-3 py-3">
            <code className="fs-6">
            {`let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает`}
            </code>
        </pre>
        <p>Или мы можем обратиться к свойству <code className="fs-6">symbol.description</code>, чтобы вывести только описание:</p>
        <pre className="text-bg-dark px-3 py-3">
            <code className="fs-6">
        {`let id = Symbol("id");
alert(id.description); // id`}
            </code>
        </pre>
    </div>
    <h2>«Скрытые» свойства</h2>
    <p>Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.</p>
    <p>Например, мы работаем с объектами <code className="fs-6">user</code>, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.</p>
    <p>Используем для этого символьный ключ:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу`}
        </code>
    </pre>
    <p>Почему же лучше использовать <code className="fs-6">Symbol("id")</code>, а не строку <code className="fs-6">"id"</code>?</p>
    <p>Так как объект <code className="fs-6">user</code> принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.</p>
    <p>Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект <code className="fs-6">user</code>. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.</p>
    <p>Сторонний код может создать для этого свой символ <code className="fs-6">Symbol("id")</code>:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`// ...
let id = Symbol("id");

user[id] = "Их идентификатор";`}
        </code>
    </pre>
    <p>Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают.</p>
    <p>А вот если бы мы использовали строку <code className="fs-6">"id"</code> вместо символа, то тогда был бы конфликт:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`let user = { name: "Вася" };

// Объявляем в нашем скрипте свойство "id"
user.id = "Наш идентификатор";

// ...другой скрипт тоже хочет свой идентификатор...

user.id = "Их идентификатор"
// Ой! Свойство перезаписано сторонней библиотекой!`}
        </code>
    </pre>
    <h2>Символы в литеральном объекте</h2>
    <p>Если мы хотим использовать символ при литеральном объявлении объекта <code className="fs-6">{`{...}`}</code>, его необходимо заключить в квадратные скобки.</p>
    <p>Вот так:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};`}
        </code>
    </pre>
    <p>Это вызвано тем, что нам нужно использовать значение переменной <code className="fs-6">id</code> в качестве ключа, а не строку <code className="fs-6">«id»</code>.</p>
    <h2>Символы игнорируются циклом for…in</h2>
    <p>Свойства, чьи ключи – символы, не перебираются циклом <code className="fs-6">for..in</code>.</p>
    <p>Например:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`let id = Symbol("id");
let user = {
    name: "Вася",
    age: 30,
    [id]: 123
};

for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)

// хотя прямой доступ по символу работает
alert( "Напрямую: " + user[id] );`}
        </code>
    </pre>
    <p>Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. <code className="fs-6">Object.keys(user)</code> также игнорирует символы.</p>
    <p>А вот <code className="fs-6">Object.assign</code>, в отличие от цикла <code className="fs-6">for..in</code>, копирует и строковые, и символьные свойства:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
    {`let id = Symbol("id");
let user = {
     [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123`}
        </code>
    </pre>
    <p>Здесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что, когда мы клонируем или объединяем объекты, мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами, как, например, <code className="fs-6">id</code> в примере выше).</p>
    <h2>Глобальные символы</h2>
    <p>Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу <code className="fs-6">"id"</code>, подразумевая именно одно и то же свойство.</p>
    <p>Для этого существует <em>глобальный реестр символов</em>. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.</p>
    <p>Для чтения (или, при отсутствии, создания) символа из реестра используется вызов <code className="fs-6">Symbol.for(key)</code>.</p>
    <p>Он проверяет глобальный реестр и, при наличии в нём символа с именем <code className="fs-6">key</code>, возвращает его, иначе же создаётся новый символ <code className="fs-6">Symbol(key)</code> и записывается в реестр под ключом <code className="fs-6">key</code>.</p>
    <p>Например:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true`}
        </code>
    </pre>
    <p>Символы, содержащиеся в реестре, называются глобальными символами. Если вам нужен символ, доступный везде в коде – используйте глобальные символы.</p>
    <h2>Symbol.keyFor</h2>
    <p>Для глобальных символов, кроме <code className="fs-6">Symbol.for(key)</code>, который ищет символ по имени, существует обратный метод: <code className="fs-6">Symbol.keyFor(sym)</code>, который, наоборот, принимает глобальный символ и возвращает его имя.</p>
    <p>К примеру:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id`}
        </code>
    </pre>
    <p>Внутри метода <code className="fs-6">Symbol.keyFor</code> используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт <code className="fs-6">undefined</code>.</p>
    <p>Впрочем, для любых символов доступно свойство <code className="fs-6">description</code>.</p>
    <p>Например:</p>
    <pre className="text-bg-dark px-3 py-3">
        <code className="fs-6">
        {`let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
alert( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа

alert( localSymbol.description ); // name`}
        </code>
    </pre>
    <h2>Системные символы</h2>
    <p>Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.</p>
    <p>Эти символы перечислены в спецификации в таблице <a href="https://tc39.github.io/ecma262/#sec-well-known-symbols">Well-known symbols</a>:</p>
    <ul>
        <li>
            <p><code className="fs-6">Symbol.hasInstance</code></p>
        </li>
        <li>
            <p><code className="fs-6">Symbol.isConcatSpreadable</code></p>
        </li>
        <li>
            <p><code className="fs-6">Symbol.iterator</code></p>
        </li>
        <li>
            <p><code className="fs-6">Symbol.toPrimitive</code></p>
        </li>
        <li>
            <p>…и так далее.</p>
        </li>
    </ul>
    <p>В частности, <code className="fs-6">Symbol.toPrimitive</code> позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву.</p>
    <h2>Итого</h2>
    <p>Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.</p>
    <p>Символы создаются вызовом функции <code className="fs-6">Symbol()</code>, в которую можно передать описание (имя) символа.</p>
    <p>Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов <code className="fs-6">Symbol.for(key)</code> возвращает (или создаёт) глобальный символ с <code className="fs-6">key</code> в качестве имени. Многократные вызовы команды <code className="fs-6">Symbol.for</code> с одним и тем же аргументом возвращают один и тот же символ.</p>
    <p>Символы имеют два основных варианта использования:</p>
    <ol>
        <li>
            <p>«Скрытые» свойства объектов.</p>
            <p>Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в <code className="fs-6">for..in</code>, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.</p>
            <p>Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.</p>
        </li>
        <li>
            <p>Существует множество системных символов, используемых внутри JavaScript, доступных как <code className="fs-6">Symbol.*</code>. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов.</p>
        </li>
    </ol>
    <p>Технически символы скрыты не на 100%. Существует встроенный метод <code className="fs-6">Object.getOwnPropertySymbols(obj)</code> – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод <code className="fs-6">Reflect.ownKeys(obj)</code>, который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.</p>

    </>
    );
}

export default SymbolType;